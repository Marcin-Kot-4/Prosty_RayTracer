.TH "D:/RayTracing/include/SDL_cpuinfo.h" 3 "Mon Jan 24 2022" "Version 1.0" "RayTracer" \" -*- nroff -*-
.ad l
.nh
.SH NAME
D:/RayTracing/include/SDL_cpuinfo.h
.SH SYNOPSIS
.br
.PP
\fC#include 'SDL_stdinc\&.h'\fP
.br
\fC#include 'begin_code\&.h'\fP
.br
\fC#include 'close_code\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSDL_CACHELINE_SIZE\fP   128"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBDECLSPEC\fP int \fBSDLCALL\fP \fBSDL_GetCPUCount\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP int \fBSDLCALL\fP \fBSDL_GetCPUCacheLineSize\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasRDTSC\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasAltiVec\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasMMX\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_Has3DNow\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasSSE\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasSSE2\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasSSE3\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasSSE41\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasSSE42\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasAVX\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasAVX2\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasAVX512F\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasARMSIMD\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP \fBSDL_HasNEON\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP int \fBSDLCALL\fP \fBSDL_GetSystemRAM\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBsize_t\fP \fBSDLCALL\fP \fBSDL_SIMDGetAlignment\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBvoid\fP *\fBSDLCALL\fP \fBSDL_SIMDAlloc\fP (const \fBsize_t\fP \fBlen\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBvoid\fP *\fBSDLCALL\fP \fBSDL_SIMDRealloc\fP (\fBvoid\fP *mem, const \fBsize_t\fP \fBlen\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBvoid\fP \fBSDLCALL\fP \fBSDL_SIMDFree\fP (\fBvoid\fP *ptr)"
.br
.in -1c
.SH "Detailed Description"
.PP 
CPU feature detection for SDL\&. 
.SH "Macro Definition Documentation"
.PP 
.SS "#define SDL_CACHELINE_SIZE   128"

.SH "Function Documentation"
.PP 
.SS "\fBDECLSPEC\fP int \fBSDLCALL\fP SDL_GetCPUCacheLineSize (\fBvoid\fP)"
Determine the L1 cache line size of the CPU\&.
.PP
This is useful for determining multi-threaded structure padding or SIMD prefetch sizes\&.
.PP
\fBReturns\fP
.RS 4
the L1 cache line size of the CPU, in bytes\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.0\&. 
.RE
.PP

.SS "\fBDECLSPEC\fP int \fBSDLCALL\fP SDL_GetCPUCount (\fBvoid\fP)"
Get the number of CPU cores available\&.
.PP
\fBReturns\fP
.RS 4
the total number of logical CPU cores\&. On CPUs that include technologies such as hyperthreading, the number of logical cores may be more than the number of physical cores\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.0\&. 
.RE
.PP

.SS "\fBDECLSPEC\fP int \fBSDLCALL\fP SDL_GetSystemRAM (\fBvoid\fP)"
Get the amount of RAM configured in the system\&.
.PP
\fBReturns\fP
.RS 4
the amount of RAM configured in the system in MB\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.1\&. 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_Has3DNow (\fBvoid\fP)"
Determine whether the CPU has 3DNow! features\&.
.PP
This always returns false on CPUs that aren't using AMD instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has 3DNow! features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_HasAltiVec\fP 
.PP
\fBSDL_HasAVX\fP 
.PP
\fBSDL_HasAVX2\fP 
.PP
\fBSDL_HasMMX\fP 
.PP
\fBSDL_HasRDTSC\fP 
.PP
\fBSDL_HasSSE\fP 
.PP
\fBSDL_HasSSE2\fP 
.PP
\fBSDL_HasSSE3\fP 
.PP
\fBSDL_HasSSE41\fP 
.PP
\fBSDL_HasSSE42\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasAltiVec (\fBvoid\fP)"
Determine whether the CPU has AltiVec features\&.
.PP
This always returns false on CPUs that aren't using PowerPC instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has AltiVec features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_Has3DNow\fP 
.PP
\fBSDL_HasAVX\fP 
.PP
\fBSDL_HasAVX2\fP 
.PP
\fBSDL_HasMMX\fP 
.PP
\fBSDL_HasRDTSC\fP 
.PP
\fBSDL_HasSSE\fP 
.PP
\fBSDL_HasSSE2\fP 
.PP
\fBSDL_HasSSE3\fP 
.PP
\fBSDL_HasSSE41\fP 
.PP
\fBSDL_HasSSE42\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasARMSIMD (\fBvoid\fP)"
Determine whether the CPU has ARM SIMD (ARMv6) features\&.
.PP
This is different from ARM NEON, which is a different instruction set\&.
.PP
This always returns false on CPUs that aren't using ARM instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has ARM SIMD features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.12\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_HasNEON\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasAVX (\fBvoid\fP)"
Determine whether the CPU has AVX features\&.
.PP
This always returns false on CPUs that aren't using Intel instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has AVX features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.2\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_Has3DNow\fP 
.PP
\fBSDL_HasAltiVec\fP 
.PP
\fBSDL_HasAVX2\fP 
.PP
\fBSDL_HasMMX\fP 
.PP
\fBSDL_HasRDTSC\fP 
.PP
\fBSDL_HasSSE\fP 
.PP
\fBSDL_HasSSE2\fP 
.PP
\fBSDL_HasSSE3\fP 
.PP
\fBSDL_HasSSE41\fP 
.PP
\fBSDL_HasSSE42\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasAVX2 (\fBvoid\fP)"
Determine whether the CPU has AVX2 features\&.
.PP
This always returns false on CPUs that aren't using Intel instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has AVX2 features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.4\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_Has3DNow\fP 
.PP
\fBSDL_HasAltiVec\fP 
.PP
\fBSDL_HasAVX\fP 
.PP
\fBSDL_HasMMX\fP 
.PP
\fBSDL_HasRDTSC\fP 
.PP
\fBSDL_HasSSE\fP 
.PP
\fBSDL_HasSSE2\fP 
.PP
\fBSDL_HasSSE3\fP 
.PP
\fBSDL_HasSSE41\fP 
.PP
\fBSDL_HasSSE42\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasAVX512F (\fBvoid\fP)"
Determine whether the CPU has AVX-512F (foundation) features\&.
.PP
This always returns false on CPUs that aren't using Intel instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has AVX-512F features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.9\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_HasAVX\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasMMX (\fBvoid\fP)"
Determine whether the CPU has MMX features\&.
.PP
This always returns false on CPUs that aren't using Intel instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has MMX features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_Has3DNow\fP 
.PP
\fBSDL_HasAltiVec\fP 
.PP
\fBSDL_HasAVX\fP 
.PP
\fBSDL_HasAVX2\fP 
.PP
\fBSDL_HasRDTSC\fP 
.PP
\fBSDL_HasSSE\fP 
.PP
\fBSDL_HasSSE2\fP 
.PP
\fBSDL_HasSSE3\fP 
.PP
\fBSDL_HasSSE41\fP 
.PP
\fBSDL_HasSSE42\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasNEON (\fBvoid\fP)"
Determine whether the CPU has NEON (ARM SIMD) features\&.
.PP
This always returns false on CPUs that aren't using ARM instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has ARM NEON features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.6\&. 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasRDTSC (\fBvoid\fP)"
Determine whether the CPU has the RDTSC instruction\&.
.PP
This always returns false on CPUs that aren't using Intel instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has the RDTSC instruction or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_Has3DNow\fP 
.PP
\fBSDL_HasAltiVec\fP 
.PP
\fBSDL_HasAVX\fP 
.PP
\fBSDL_HasAVX2\fP 
.PP
\fBSDL_HasMMX\fP 
.PP
\fBSDL_HasSSE\fP 
.PP
\fBSDL_HasSSE2\fP 
.PP
\fBSDL_HasSSE3\fP 
.PP
\fBSDL_HasSSE41\fP 
.PP
\fBSDL_HasSSE42\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasSSE (\fBvoid\fP)"
Determine whether the CPU has SSE features\&.
.PP
This always returns false on CPUs that aren't using Intel instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has SSE features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_Has3DNow\fP 
.PP
\fBSDL_HasAltiVec\fP 
.PP
\fBSDL_HasAVX\fP 
.PP
\fBSDL_HasAVX2\fP 
.PP
\fBSDL_HasMMX\fP 
.PP
\fBSDL_HasRDTSC\fP 
.PP
\fBSDL_HasSSE2\fP 
.PP
\fBSDL_HasSSE3\fP 
.PP
\fBSDL_HasSSE41\fP 
.PP
\fBSDL_HasSSE42\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasSSE2 (\fBvoid\fP)"
Determine whether the CPU has SSE2 features\&.
.PP
This always returns false on CPUs that aren't using Intel instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has SSE2 features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_Has3DNow\fP 
.PP
\fBSDL_HasAltiVec\fP 
.PP
\fBSDL_HasAVX\fP 
.PP
\fBSDL_HasAVX2\fP 
.PP
\fBSDL_HasMMX\fP 
.PP
\fBSDL_HasRDTSC\fP 
.PP
\fBSDL_HasSSE\fP 
.PP
\fBSDL_HasSSE3\fP 
.PP
\fBSDL_HasSSE41\fP 
.PP
\fBSDL_HasSSE42\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasSSE3 (\fBvoid\fP)"
Determine whether the CPU has SSE3 features\&.
.PP
This always returns false on CPUs that aren't using Intel instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has SSE3 features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_Has3DNow\fP 
.PP
\fBSDL_HasAltiVec\fP 
.PP
\fBSDL_HasAVX\fP 
.PP
\fBSDL_HasAVX2\fP 
.PP
\fBSDL_HasMMX\fP 
.PP
\fBSDL_HasRDTSC\fP 
.PP
\fBSDL_HasSSE\fP 
.PP
\fBSDL_HasSSE2\fP 
.PP
\fBSDL_HasSSE41\fP 
.PP
\fBSDL_HasSSE42\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasSSE41 (\fBvoid\fP)"
Determine whether the CPU has SSE4\&.1 features\&.
.PP
This always returns false on CPUs that aren't using Intel instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has SSE4\&.1 features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_Has3DNow\fP 
.PP
\fBSDL_HasAltiVec\fP 
.PP
\fBSDL_HasAVX\fP 
.PP
\fBSDL_HasAVX2\fP 
.PP
\fBSDL_HasMMX\fP 
.PP
\fBSDL_HasRDTSC\fP 
.PP
\fBSDL_HasSSE\fP 
.PP
\fBSDL_HasSSE2\fP 
.PP
\fBSDL_HasSSE3\fP 
.PP
\fBSDL_HasSSE42\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBSDL_bool\fP \fBSDLCALL\fP SDL_HasSSE42 (\fBvoid\fP)"
Determine whether the CPU has SSE4\&.2 features\&.
.PP
This always returns false on CPUs that aren't using Intel instruction sets\&.
.PP
\fBReturns\fP
.RS 4
SDL_TRUE if the CPU has SSE4\&.2 features or SDL_FALSE if not\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_Has3DNow\fP 
.PP
\fBSDL_HasAltiVec\fP 
.PP
\fBSDL_HasAVX\fP 
.PP
\fBSDL_HasAVX2\fP 
.PP
\fBSDL_HasMMX\fP 
.PP
\fBSDL_HasRDTSC\fP 
.PP
\fBSDL_HasSSE\fP 
.PP
\fBSDL_HasSSE2\fP 
.PP
\fBSDL_HasSSE3\fP 
.PP
\fBSDL_HasSSE41\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBvoid\fP *\fBSDLCALL\fP SDL_SIMDAlloc (const \fBsize_t\fP len)"
Allocate memory in a SIMD-friendly way\&.
.PP
This will allocate a block of memory that is suitable for use with SIMD instructions\&. Specifically, it will be properly aligned and padded for the system's supported vector instructions\&.
.PP
The memory returned will be padded such that it is safe to read or write an incomplete vector at the end of the memory block\&. This can be useful so you don't have to drop back to a scalar fallback at the end of your SIMD processing loop to deal with the final elements without overflowing the allocated buffer\&.
.PP
You must free this memory with SDL_FreeSIMD(), not free() or \fBSDL_free()\fP or delete[], etc\&.
.PP
Note that SDL will only deal with SIMD instruction sets it is aware of; for example, SDL 2\&.0\&.8 knows that SSE wants 16-byte vectors (\fBSDL_HasSSE()\fP), and AVX2 wants 32 bytes (\fBSDL_HasAVX2()\fP), but doesn't know that AVX-512 wants
.IP "64." 4
To be clear: if you can't decide to use an instruction set with an SDL_Has*() function, don't use that instruction set with memory allocated through here\&.
.PP
.PP
SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't out of memory, but you are not allowed to dereference it (because you only own zero bytes of that buffer)\&.
.PP
\fBParameters\fP
.RS 4
\fIlen\fP The length, in bytes, of the block to allocate\&. The actual allocated block might be larger due to padding, etc\&. 
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to the newly-allocated block, NULL if out of memory\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.10\&.
.RE
.PP
\fBSee also\fP
.RS 4
SDL_SIMDAlignment 
.PP
\fBSDL_SIMDRealloc\fP 
.PP
\fBSDL_SIMDFree\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBvoid\fP \fBSDLCALL\fP SDL_SIMDFree (\fBvoid\fP * ptr)"
Deallocate memory obtained from SDL_SIMDAlloc
.PP
It is not valid to use this function on a pointer from anything but \fBSDL_SIMDAlloc()\fP or \fBSDL_SIMDRealloc()\fP\&. It can't be used on pointers from malloc, realloc, SDL_malloc, memalign, new[], etc\&.
.PP
However, SDL_SIMDFree(NULL) is a legal no-op\&.
.PP
The memory pointed to by \fCptr\fP is no longer valid for access upon return, and may be returned to the system or reused by a future allocation\&. The pointer passed to this function is no longer safe to dereference once this function returns, and should be discarded\&.
.PP
\fBParameters\fP
.RS 4
\fIptr\fP The pointer, returned from SDL_SIMDAlloc or SDL_SIMDRealloc, to deallocate\&. NULL is a legal no-op\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.10\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBSDL_SIMDAlloc\fP 
.PP
\fBSDL_SIMDRealloc\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBsize_t\fP \fBSDLCALL\fP SDL_SIMDGetAlignment (\fBvoid\fP)"
Report the alignment this system needs for SIMD allocations\&.
.PP
This will return the minimum number of bytes to which a pointer must be aligned to be compatible with SIMD instructions on the current machine\&. For example, if the machine supports SSE only, it will return 16, but if it supports AVX-512F, it'll return 64 (etc)\&. This only reports values for instruction sets SDL knows about, so if your SDL build doesn't have \fBSDL_HasAVX512F()\fP, then it might return 16 for the SSE support it sees and not 64 for the AVX-512 instructions that exist but SDL doesn't know about\&. Plan accordingly\&.
.PP
\fBReturns\fP
.RS 4
the alignment in bytes needed for available, known SIMD instructions\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.10\&. 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBvoid\fP *\fBSDLCALL\fP SDL_SIMDRealloc (\fBvoid\fP * mem, const \fBsize_t\fP len)"
Reallocate memory obtained from SDL_SIMDAlloc
.PP
It is not valid to use this function on a pointer from anything but \fBSDL_SIMDAlloc()\fP\&. It can't be used on pointers from malloc, realloc, SDL_malloc, memalign, new[], etc\&.
.PP
\fBParameters\fP
.RS 4
\fImem\fP The pointer obtained from SDL_SIMDAlloc\&. This function also accepts NULL, at which point this function is the same as calling SDL_SIMDAlloc with a NULL pointer\&. 
.br
\fIlen\fP The length, in bytes, of the block to allocated\&. The actual allocated block might be larger due to padding, etc\&. Passing 0 will return a non-NULL pointer, assuming the system isn't out of memory\&. 
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to the newly-reallocated block, NULL if out of memory\&.
.RE
.PP
\fBSince\fP
.RS 4
This function is available since SDL 2\&.0\&.14\&.
.RE
.PP
\fBSee also\fP
.RS 4
SDL_SIMDAlignment 
.PP
\fBSDL_SIMDAlloc\fP 
.PP
\fBSDL_SIMDFree\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for RayTracer from the source code\&.
